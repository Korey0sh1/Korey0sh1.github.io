

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/browser.jpg">
  <link rel="icon" href="/img/browser.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="korey0sh1">
  <meta name="keywords" content="">
  
    <meta name="description" content="请支持国产操作系统korey OS喵，永雏塔菲喵">
<meta property="og:type" content="article">
<meta property="og:title" content="关于作死试图搓一个32位操作系统不得不说的事">
<meta property="og:url" content="http://example.com/2023/11/20/OS/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="请支持国产操作系统korey OS喵，永雏塔菲喵">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/OS/index.jpg">
<meta property="article:published_time" content="2023-11-20T07:19:03.000Z">
<meta property="article:modified_time" content="2023-12-30T11:33:28.583Z">
<meta property="article:author" content="korey0sh1">
<meta property="article:tag" content="OS">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="kernel">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/OS/index.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>关于作死试图搓一个32位操作系统不得不说的事 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.6","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>korey0sh1</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/OS/banner.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="关于作死试图搓一个32位操作系统不得不说的事"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        korey0sh1
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-11-20 15:19" pubdate>
          2023年11月20日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          7.4k 字
        
      </span>
    

    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">关于作死试图搓一个32位操作系统不得不说的事</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2023年12月30日 晚上
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="0x0-写在一切之前"><a href="#0x0-写在一切之前" class="headerlink" title="0x0:写在一切之前"></a>0x0:写在一切之前</h1><p>本来在笔者的计划中，手搓一个简易的操作系统是在暑假就该完成的事情，结果笔者是只懒🐶，而且当时一直在搞fuzz和iot<del>（但好像也没搞出什么东西来，只是单纯的在摸鱼罢了）</del>。</p>
<p>然后呢笔者最近想重开kernel，静下心来好好学点内核。但掐指一算好像还有两个星期就到期末周了，学个🐕8</p>
<p>👴当🐓立断不如看点书，参考一下《操作系统真象还原》，基础能打一点是一点。</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="bochs安装"><a href="#bochs安装" class="headerlink" title="bochs安装"></a>bochs安装</h3><p><a target="_blank" rel="noopener" href="https://sourceforge.net/projects/bochs/files/bochs/">Bochs x86 PC emulator - Browse &#x2F;bochs at SourceForge.net</a></p>
<p>找个版本下载并解压</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ <span class="hljs-string">./configure</span> <span class="hljs-params">--prefix=/your/path/yo/bochs</span> <span class="hljs-params">--enable-debugger</span> <span class="hljs-params">--enable-disasm</span> <span class="hljs-params">--enable-iodebug</span> <span class="hljs-params">--enable-x86-debugger</span> <span class="hljs-params">--with-x</span> <span class="hljs-params">--with-x11</span><br>$ make<br>$ make install<br></code></pre></td></tr></table></figure>

<p><code>bochs</code>支持自带的<code>debug</code>和<code>gdb</code>（编译的时候-<code>-enable-debugger</code>变成<code>--enable-gdb-stub</code>），但gdb这适配做的是一坨shit，建议直接用<code>bochs</code>自带的</p>
<p>配置文件，抄的A3👴的呜呜，把<code>share/doc/bochs/bochsrc-sample.txt</code>里的改一改</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">megs: 32<br>romimage: <span class="hljs-attribute">file</span>=./bochs/share/bochs/BIOS-bochs-latest<br>vgaromimage: <span class="hljs-attribute">file</span>=./bochs/share/bochs/VGABIOS-lgpl-latest<br>ata0-master: <span class="hljs-attribute">type</span>=disk, <span class="hljs-attribute">mode</span>=flat, <span class="hljs-attribute">path</span>=<span class="hljs-string">&quot;img.img&quot;</span><br>cpu: <span class="hljs-attribute">model</span>=pentium, <span class="hljs-attribute">count</span>=1, <span class="hljs-attribute">ips</span>=50000000, <span class="hljs-attribute">reset_on_triple_fault</span>=1, <span class="hljs-attribute">ignore_bad_msrs</span>=1, <span class="hljs-attribute">msrs</span>=<span class="hljs-string">&quot;msrs.def&quot;</span><br><span class="hljs-comment"># following lines need to be added by yourself</span><br>keyboard: <span class="hljs-attribute">type</span>=mf, <span class="hljs-attribute">serial_delay</span>=250 <span class="hljs-attribute">keymap</span>=./bochs/share/bochs/keymaps/x11-pc-us.map<br><span class="hljs-comment">#sound: driver=default, waveout=/dev/dsp. wavein=, midiout= </span><br></code></pre></td></tr></table></figure>

<h3 id="bochs-调试"><a href="#bochs-调试" class="headerlink" title="bochs 调试"></a>bochs 调试</h3><p>大部分调试命令和gdb一样，有几个特殊的</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> mode:每次 CPU 变换模式时就提示，模式是指保护模式、实模式，比如从实模式进入到保护模式时会有提示<br><br><span class="hljs-keyword">show</span> <span class="hljs-type">int</span>:每次有中断时就提示 p 同时显示三种中断类型，这 三 种中断类型包括“ softint ”、“ extint ”和“ iret ”。可以单独显示某类中断，如执行 <span class="hljs-keyword">show</span> softint 只显示软件主动触发的中断， <span class="hljs-keyword">show</span> extint 则只显示来自外部设备的中断， <span class="hljs-keyword">show</span> iret 只显示 iretd 指令有关的信息 <br><br>reg：常用寄存器的值<br><br><span class="hljs-keyword">info</span> gdt/ldt/CPU/idt/ivt：全局符号描述表/局部符号描述表/所有CPU寄存器的值/显示中断向量表IDT/显示中断向量表IVT<br><br>sreg：查看段寄存器的值<br>dreg：查看调试寄存器的值<br>creg：查看控制寄存器的值<br></code></pre></td></tr></table></figure>

<h3 id="pack-start"><a href="#pack-start" class="headerlink" title="pack &amp; start"></a>pack &amp; start</h3><p>pack.sh</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">!/bin/bash<br>nasm -o ./mbr.bin ./mbr.S<br>./bochs/bin/bximage <span class="hljs-attribute">-mode</span>=create <span class="hljs-attribute">-hd</span>=60M <span class="hljs-attribute">-imgmode</span>=<span class="hljs-string">&quot;flat&quot;</span> -q ./img.img<br>dd <span class="hljs-attribute">if</span>=./mbr.bin <span class="hljs-attribute">of</span>=./img.img <span class="hljs-attribute">bs</span>=512 <span class="hljs-attribute">count</span>=1 <span class="hljs-attribute">conv</span>=notrunc<br></code></pre></td></tr></table></figure>

<p>start.sh</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>./bochs/bin/bochs -f ./bochsrc.disk<br></code></pre></td></tr></table></figure>

<h1 id="0x1-开始调教MBR（bushi）🥵"><a href="#0x1-开始调教MBR（bushi）🥵" class="headerlink" title="0x1:开始调教MBR（bushi）🥵"></a>0x1:开始调教MBR（bushi）🥵</h1><h2 id="about-BIOS"><a href="#about-BIOS" class="headerlink" title="about BIOS"></a>about BIOS</h2><p>众所周知，当你按下神圣的开机键，<code>CPU</code>通上电之后以实模式启动，第一个运行的程序便是<code>BIOS</code>，<code>BIOS</code>将<code>MBR</code>载入，将控制权交给了<code>MBR</code></p>
<p>于是便产生了玄学三问：<code>BIOS</code>是什么？他从哪来？为什么他先执行？</p>
<p>首先先看张《操作系统真象还原》里的图，关于实模式下的内存分布</p>
<p><img src="/img/OS/0.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><code>BIOS</code>：<code>Basic Input &amp; Output System</code>即基本输入输出系统，主要工作便是检测、初始化硬件，还建立了伟大的中断向量表</p>
<p>但是通过图可知，<code>BIOS</code>才<code>0xf0000-0xfffff</code>共计<code>64KB</code>大小，不可能兼顾到所有的硬件设备，而且此时运行在实模式下，也没有这个必要，所以只要挑一些重要的，能保证计算机运行的基本硬件IO操作就行了。此为<code>BIOS</code>名称由来</p>
<p>至于<code>BIOS</code>在哪里，这玩意一直在主板上的<code>ROM</code>里，通电的时候<code>ROM</code>就被映射在<code>0xf0000-0xfffff</code>,只要访问了这里就算访问了<code>BIOS</code>,这个映射完全是由硬件完成的。</p>
<p>But <code>BIOS</code>也算是个程序，所以也是有入口的，此处便是<code>0xffff0</code>。电脑开机的一瞬间，CPU的<code>cs:ip</code>寄存器被赋值为<code>0xf000</code>:<code>0xfff0</code>。然后开机时处于实模式，段基址<code>cs</code>要左移四位，所以此时<code>cs:ip</code>等效地址为<code>0xffff0</code>，为<code>BIOS</code>入口。</p>
<p>但是<code>0xffff0-0xfffff</code>这短短的16字节显然并不能干什么，通过调试发现，<code>0xffff0</code>处的指令实为跳转指令，跳到<code>0xfe05b</code>处。这才是<code>BIOS</code>真正开始的地方</p>
<p><img src="/img/OS/1.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>当初始化硬件和建立中断向量表后，<code>BIOS</code>将自己最后的波纹用于检查0盘0道1扇区（实则是0盘0道0扇区，CHS表示方式中1扇区就是第一个扇区）最后两个字节是否为<code>magic number</code> <strong>0x55</strong>和<strong>0xaa</strong>（你问👴为什么不是114514这种恶臭的杂修~，👴知道个der，反正书里写了）。如果是，就会把这个扇区的<code>data</code>加载到<code>0x7c00</code>,随后跳转执行。此处执行的，便是MBR。如果你问完<code>magic number</code>又要问👴为什么是<code>0x7c00</code>,👴只能说是<code>IBM生产的PC5150的ROM BIOS 中的INT19H</code>的历史遗留问题，当时的<code>BIOS</code>按<code>32KB</code>的大小来设计，<code>32KB</code>就是<code>0x8000</code>，<code>MBR</code>的大小是512字节，同时作为一个程序需要使用栈，姑且算<code>1KB</code>好了。<code>1KB</code>是多少，<code>0x400</code>，所以<code>0x8000</code> - <code>0x400</code>是<code>0x7c00</code>。</p>
<h2 id="MBRの初次调教"><a href="#MBRの初次调教" class="headerlink" title="MBRの初次调教"></a>MBRの初次调教</h2><p>写了这么多终于到<code>MBR</code>了，妈妈生的</p>
<p><code>MBR（Master Boot Recode）</code>——主引导记录，是我们能最早支配的程序，因为<code>BIOS</code>这byd是写死的。</p>
<p>需要注意的是，MBR的大小必须是512字节，因为只有这样才能保证0道0盘1扇区的最后两个字节为<code>magic</code>。</p>
<p>先写一个在屏幕上输出字符的<code>MBR</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs assembly">SECTION MBR vstart=0x7c00    ;因为MBR被加载到0x7c00，所以将整个code作为section，并将vstart赋值0x7c00，这样计算绝对地址时就会以0x7c00为base<br>	mov ax,cs                ;段寄存器不能用立即数，只能通过寄存器或者内存进行赋值<br>	mov ds,ax<br>	mov es,ax<br>	mov ss,ax<br>	mov fs,ax<br>	mov sp,0x7c00<br>	<br>	mov ax,0x600             ;上卷全部行，清屏<br>	mov bx,0x700<br>	mov cx,0                 ;左上角（0，0）<br>	mov dx,0x184f         	 ;右下角（80，25）<br>	int 0x10                 ;BIOS提供的0x10中断<br><br> 	mov ah,3                 ;获取光标位置<br>	mov bh,0<br>	int 0x10<br><br>	mov ax,message           ;es:bp是字符串地址，因为前面es已经被初始化，所以cs=es<br>	mov bp,ax<br>	<br>	mov cx,0x20              ;length <br>	mov ax,0x1301            ;ah:01 显示字符串，光标跟随移动<br>	mov bx,0x2               ;bl:02 黑底绿字<br>	int 0x10 <br><br>	jmp $                    ;$表示当前行，程序在这边卡住<br><br>	message db &quot;The First MBR of Korey0sh1&quot;<br> 	times 510-($-$$) db 0    ;$$表示section的位置，填充510的length，补上magic number<br>	db 0x55,0xaa   <br></code></pre></td></tr></table></figure>

<p>运行后可以康康</p>
<p><img src="/img/OS/2.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>输出的时候写了个循环，优化一下，不用算length了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs assembly">SECTION MBR vstart=0x7c00<br>	mov ax,cs<br>	mov ds,ax<br>	mov es,ax<br>	mov ss,ax<br>	mov fs,ax<br>	mov sp,0x7c00<br>	<br>	mov ax,0x600<br>	mov bx,0x700<br>	mov cx,0<br>	mov dx,0x184f<br>	int 0x10<br><br>	mov ax,message<br>	mov bp,ax<br>	<br>.korey_print:<br><br> 	mov ah,3<br>	mov bh,0<br>	int 0x10<br>	<br>	mov cx,1<br>	mov ax,0x1301<br>	mov bx,0x2<br>	int 0x10<br>        <br>    inc bp<br>    mov ax,[bp]<br>    test ax,ax<br>    jnz .korey_print<br>       <br>	jmp $<br><br>	message db &quot;The First MBR of Korey0sh1&quot;<br> 	times 510-($-$$) db 0<br>	db 0x55,0xaa<br></code></pre></td></tr></table></figure>

<h2 id="变成显存形状的MBR"><a href="#变成显存形状的MBR" class="headerlink" title="变成显存形状的MBR"></a>变成显存形状的MBR</h2><p>前面的<code>MBR</code>，使用<code>BIOS</code>提供的0x10中断完成了字符输出，说实话还是依赖于中断向量表。</p>
<p>But，中断向量表只存在于实模式，以后还是要进入保护模式的捏，但保护模式就莫得中断向量表了，也就无法使用int 0x10来完成输出了。</p>
<p>那该怎么办捏</p>
<p>答案就是直接对显卡上手。</p>
<p>显卡显卡，就是用来图像输出的卡。而显卡中的显存，是显卡提供给我们的接口。关于实模式的内存分布中提到<code>0xA0000</code>-<code>0xC7FFF</code>是显存的区域，事实上，当你直接在显存上写东西。显卡便会在屏幕上输出内容</p>
<p><img src="/img/OS/3.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>下面是在显存文本模式区域（一个字节表示输出字符，一个字符表示其属性）输出<code>“korey&quot;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs assembly">SECTION MBR vstart=0x7c00<br>	mov ax,cs<br>	mov ds,ax<br>	mov es,ax<br>	mov ss,ax<br>	mov fs,ax<br>	mov sp,0x7c00<br>	mov ax,0xb800<br>	mov gs,ax<br>	<br>	mov ax,0x600<br>	mov bx,0x700<br>	mov cx,0<br>	mov dx,0x184f<br>	int 0x10<br><br>	mov byte [gs:0x00],&#x27;k&#x27;<br>	mov byte [gs:0x01],0xa4   ;A：背景色绿色   4：前景色红色<br>	<br>	mov byte [gs:0x02],&#x27;o&#x27;<br>	mov byte [gs:0x03],0xa4<br>	<br>	mov byte [gs:0x04],&#x27;r&#x27;<br>	mov byte [gs:0x05],0xa4<br>	<br>	mov byte [gs:0x06],&#x27;e&#x27;<br>	mov byte [gs:0x07],0xa4<br>	<br>	mov byte [gs:0x08],&#x27;y&#x27;<br>	mov byte [gs:0x09],0xa4<br>	<br>	jmp $<br>	<br> 	times 510-($-$$) db 0<br>	db 0x55,0xaa<br></code></pre></td></tr></table></figure>

<p><img src="/img/OS/4.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="MBR-和我交往吧，磁盘仙贝！😋"><a href="#MBR-和我交往吧，磁盘仙贝！😋" class="headerlink" title="MBR:和我交往吧，磁盘仙贝！😋"></a>MBR:和我交往吧，磁盘仙贝！😋</h2><p><code>BIOS</code>只能把0柱面0磁道1扇区512字节大小的<code>MBR</code>载入内存，那么问题来了，<code>MBR</code>执行完了，然后干什么嘞。</p>
<p>其实我们都知道，<code>MBR</code>也不过是一个中继程序而已，然既然<code>MBR</code>是从磁盘导入的，那我们能不能用<code>MBR</code>从磁盘导入别的<code>data</code>呢？</p>
<p>这就涉及到磁盘通信问题惹</p>
<p>先贴一张表，出自《操作系统真象还原》</p>
<p><img src="/img/OS/5.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>先来看看一些常用的端口</p>
<ul>
<li>data <code>0x1f0/0x170</code>：负责管理数据，唯一一个16位的</li>
<li>error&#x2F;feature <code>0x1f1/0x171</code>：读取硬盘失败时记录失败信息&#x2F;写入硬盘时存储命令需要的额外参数</li>
<li>Sector count <code>0x1f2/0x172</code>：指定待写入或待读取的扇区</li>
<li>device <code>0x1f6/0x176</code>：杂项寄存器，什么功能都带点。图来自《操作系统真象还原》</li>
<li><img src="/img/OS/6.png" srcset="/img/loading.gif" lazyload alt="img"></li>
<li>status （读硬盘时）<code>0x17f/0x177</code>：状态寄存器。图来自《操作系统真象还原》</li>
<li><img src="/img/OS/7.png" srcset="/img/loading.gif" lazyload alt="img"></li>
<li>command（写硬盘时）<code>0x17f/0x177</code>：储存让硬盘执行的命令。常用的就三个</li>
<li>identify: 0xEC 硬盘识别<br>read sector: 0x20 读取扇区<br>write sector: 0x30 写入扇区</li>
</ul>
<p>在物理层面上，硬盘内寻址是通过”柱面．磁头．扇区”来定位的<code>Cylinder Head Sector</code>，简称为 <code>CHS</code> ，这对读写的磁头很形象，但对于可爱的<code>MBR</code>小姐就太抽象了。于是出现了<code>LBA</code>，逻辑块地址<code>（logic block address）</code>，不考虑扇区所在的物理结构。</p>
<p>LBA又分LBA28（最大支持128G）和LBA48（最大支持128PB），我们这边就讨论LBA28</p>
<p>所以三个8位的寄存器存放<code>LBA28</code>的低24位，高4位存放在<code>device</code>寄存器的低4位</p>
<p>在<code>x86</code>架构中，与<code>IO</code>设备通信时一般会用<code>in/out</code>这两个指令，从端口读出数据或者向端口写入数据。并且默认<code>dx</code>寄存器存储端口号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov dx,0x1f0<br>in dx,al         ;这样就是向0x1f0端口写入al的值了<br></code></pre></td></tr></table></figure>

<p>至于如何从磁盘读入数据写入内存的大致步骤笔者就不赘述了，可以参考书籍</p>
<p>下面就是代码罢了</p>
<p>boot.inc</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs assembly">LOADER_BASE_ADDR equ 0x900            ;0x500-0x7bff都是可用区域<br>LOADER_START_SECTOR equ 0x2           ;扇区2<br>%include &quot;boot.inc&quot;<br>SECTION MBR vstart=0x7c00<br>	mov ax,cs                         ;initial<br>	mov ds,ax<br>	mov es,ax<br>	mov ss,ax<br>	mov fs,ax<br>	mov sp,0x7c00<br>	mov ax,0xb800<br>	mov gs,ax<br>	<br>	mov ax,0x600                      ;通过上卷清空屏幕<br>	mov bx,0x700<br>	mov cx,0<br>	mov dx,0x184f<br>	int 0x10<br>	<br>	mov eax,LOADER_START_SECTOR       ;eax = 2<br>	mov bx,LOADER_BASE_ADDR           ;bx = 0x900<br>	mov cx,1                          ;待读取扇区数 = 1<br>	call rd_disk_m_16<br>	<br>	jmp LOADER_BASE_ADDR<br>	<br>rd_disk_m_16:<br>	mov esi,eax                       ;保存参数<br>	mov di,cx<br>	 <br>	mov dx,0x1f2                      <br>	mov al,cl         <br>	out dx,al                         ;传个sector count 待读取扇区数为1<br><br>	mov eax,esi<br>	<br>	mov dx,0x1f3<br>	out dx,al                         ;LAB low<br><br>	mov cl,8<br>	shr eax,cl<br>	mov dx,0x1f4<br>	out dx,al                         ;LAB mid<br>    <br>    shr eax,cl                        <br>    mov dx,0x1f5<br>    out dx,al                         ;LAB high<br>    <br>	shr eax,cl<br>	and al,0x0f<br>	or al,0xe0<br>	mov dx,0x1f6<br>	out dx,al                         ;lba 第 24-27位。设置 7-4 位为 1110 ，表示 lba 模式            <br><br>	mov dx,0x1f7<br>	mov al,0x20<br>	out dx,al                         ;写入读取命令<br>	<br>.not_ready:                           ;还是0x1f7端口<br>	nop<br>	in al,dx<br>	and al,0x88                       ;第 4 位为 1 表示硬盘控制器已准备好数据传输  第 7 位为 1 表示硬盘忙<br>	cmp al,0x08 <br>	jnz .not_ready                    ;直到准备好为止<br><br>	mov ax,di                         <br>	mov dx,256<br>	mul dx<br>	mov cx,ax                         ;di 为要读取的扇区数，一个扇区有512字节每次读入一个字116共需 di*512/2次，所以 di*<br>	mov dx,0x1f0                      <br>	<br>.go_on_read:<br>	in ax,dx<br>	mov [bx],ax<br>	add bx,2<br>	loop .go_on_read<br>	ret<br>	<br> 	times 510-($-$$) db 0<br>	db 0x55,0xaa<br></code></pre></td></tr></table></figure>

<p>当然此时扇区2里面一点数据都没有，我们可以随便写一点loader</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs assembly">%include &quot;boot.inc&quot;<br>SECTION LOADER vstart=LOADER_BASE_ADDR<br>	mov ax,cs<br>	mov ds,ax<br>	mov es,ax<br>	mov ss,ax<br>	mov sp,LOADER_BASE_ADDR	<br>	mov ax,0xb800<br>	mov gs,ax<br><br>	mov ax,0x600<br>	mov bx,0x700<br>	mov cx,0<br>	mov dx,0x184f<br>	int 0x10<br><br>	mov byte [gs:0x00],&#x27;L&#x27;<br>	mov byte [gs:0x01],0xa4  <br>	<br>	mov byte [gs:0x02],&#x27;O&#x27;<br>	mov byte [gs:0x03],0xa4<br>	<br>	mov byte [gs:0x04],&#x27;A&#x27;<br>	mov byte [gs:0x05],0xa4<br>	<br>	mov byte [gs:0x06],&#x27;D&#x27;<br>	mov byte [gs:0x07],0xa4<br>	<br>	mov byte [gs:0x08],&#x27;E&#x27;<br>	mov byte [gs:0x09],0xa4<br><br>	mov byte [gs:0x0a],&#x27;R&#x27;<br>	mov byte [gs:0x0b],0xa4<br><br>	jmp $<br></code></pre></td></tr></table></figure>

<p>编译后dd进磁盘的扇区2，所以pack.h也得改一改</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#!/bin/bash</span><br>nasm -o ./mbr.bin ./mbr.S<br>nasm -o ./loader.bin ./load.S<br>./bochs/bin/bximage <span class="hljs-attribute">-mode</span>=create <span class="hljs-attribute">-hd</span>=60M <span class="hljs-attribute">-imgmode</span>=<span class="hljs-string">&quot;flat&quot;</span> -q ./img.img<br>dd <span class="hljs-attribute">if</span>=./mbr.bin \<br>        <span class="hljs-attribute">of</span>=./img.img \<br>        <span class="hljs-attribute">bs</span>=512 <span class="hljs-attribute">count</span>=1 <span class="hljs-attribute">conv</span>=notrunc<br>dd <span class="hljs-attribute">if</span>=./loader.bin \<br>        <span class="hljs-attribute">of</span>=./img.img \<br>        <span class="hljs-attribute">bs</span>=512 <span class="hljs-attribute">count</span>=1 <span class="hljs-attribute">seek</span>=2 <span class="hljs-attribute">conv</span>=notrunc<br></code></pre></td></tr></table></figure>

<p>然后就可以愉快的跳到0x900执行loader了</p>
<p><img src="/img/OS/8.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>但是这个loader并没有任何意义，因为他是在实模式下运行的，只是为了测试MBR的功能性。</p>
<h1 id="0x2-保护模式"><a href="#0x2-保护模式" class="headerlink" title="0x2:保护模式"></a>0x2:保护模式</h1><h2 id="段描述符（Segment-Descriptor）"><a href="#段描述符（Segment-Descriptor）" class="headerlink" title="段描述符（Segment Descriptor）"></a>段描述符（Segment Descriptor）</h2><p>随着时间的推移，8086进化成了80386，地址总线也从16位变成32位，but，段寄存器却还是16位从未变过</p>
<p>这是因为关于段的信息被存放在了内存中一块叫做<strong>段描述符</strong>的地方</p>
<p><img src="/img/OS/9.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>段描述符长8字节，64位，里面的各个位的具体含义如下</p>
<ul>
<li>0-15：段界限低16位</li>
<li>16-31：段基址低16位</li>
<li>32-39：段基址中8位</li>
<li>40-43：type 指定本描述符的类型，用于表示内存段和门的子类型。图出自《操作系统真象还原》</li>
<li><img src="/img/OS/10.png" srcset="/img/loading.gif" lazyload alt="img"></li>
<li>44：S 0&#x2F;1 —&gt; 系统段&#x2F;数据段</li>
<li>45-46：DPL ，即<code>Descriptor Privilege Level</code>，描述符特权级，分0、1、2、3，数字越小，特权级越大</li>
<li>47：P <code>Present</code>，即段是否存在 0&#x2F;1 —&gt; 不存在&#x2F;存在</li>
<li>48-51：段界限高4位</li>
<li>52：AVL，即<code>AVaiLable</code>，可用的</li>
<li>53：L，是否为64位代码段 0&#x2F;1 —&gt; 否&#x2F;是</li>
<li>54：D&#x2F;B，表示有效地址（段内偏移地址）和操作数大小 0&#x2F;1 —&gt; 16位&#x2F;32位</li>
<li>55：G，粒度 0&#x2F;1 —&gt; 1B&#x2F; 4KB</li>
<li>56-63：段基址高8位</li>
</ul>
<p>你要问👴为什么段界限和段基址会被拆成这个JB样子，👴只能说兼容、兼容、还是牛魔的兼容</p>
<h2 id="全局描述符表GDT（Global-Descriptor-Table）"><a href="#全局描述符表GDT（Global-Descriptor-Table）" class="headerlink" title="全局描述符表GDT（Global Descriptor Table）"></a>全局描述符表GDT（Global Descriptor Table）</h2><p>一个段描述符只能描述一段内存，but内存被分成许多段是无法避免的，所以这时候全局描述符表就出现了，一个内存中专门用来存放段描述符的地方。</p>
<p>程序都可以在GDT中定义自己的段描述符，CPU通过一个专门指向GDT的寄存器<code>GDTR</code>和一个“下标”，也就是<code>selector</code>选择子，在GDT中精准的找到自己需要的段描述符</p>
<h3 id="GDTR"><a href="#GDTR" class="headerlink" title="GDTR"></a>GDTR</h3><p>48位寄存器，专门用来存储GDT的内存地址和大小,下图出自《操作系统真象还原》</p>
<p><img src="/img/OS/11.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>前16位是界限值，2^16 &#x3D; 65536，所以前16位的<code>max value</code> &#x3D; 65536 -1 &#x3D; 0xffff</p>
<p><code>and</code>一个段描述符长8字节，所以一个<code>GDT</code>最多存储8192个段描述符</p>
<p><strong>lgdt</strong>:对GDTR特攻指令，具体操作为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">lgdt 48位内存数据<br></code></pre></td></tr></table></figure>

<h3 id="selector"><a href="#selector" class="headerlink" title="selector"></a>selector</h3><p>选择子是16位，下图出自《操作系统真象还原》</p>
<p><img src="/img/OS/12.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>0-1位：RPL，请求特权级，00为0，11为3</p>
<p>2位：TI，即<code>Table Indicator</code>，0为<code>GDT</code>中索引描述符，1为<code>LDT</code>（有全局当然也会有局部，<code>Local Descriptor Table</code>，局部描述符表）中索引描述表</p>
<p>高13位是索引值，2^13 &#x3D; 8192，即最多能有8192个段描述符，和上文相符</p>
<p><strong>PS：GDT中第0个索引值不可用，因为selector未初始化时为0</strong></p>
<p>至于<code>LDT</code>，和<code>GD</code>T类似，就不再赘述</p>
<h2 id="打开A20地址线"><a href="#打开A20地址线" class="headerlink" title="打开A20地址线"></a>打开A20地址线</h2><p>先来说说8086的地址回绕</p>
<h3 id="8086地址回绕"><a href="#8086地址回绕" class="headerlink" title="8086地址回绕"></a>8086地址回绕</h3><p>8086的地址总线是20位的，所以有A0-A19这20根地址线</p>
<p>在实模式下，采用段基址*16+偏移的寻址方式，不难发现，当0xffff：0xffff时，此时的逻辑地址是0x10ffef，但是，20位地址总线的最大值是0xfffff，在逻辑上这是正确的，但在物理内存中没有相应的地址。为了避免这个bug，所以8086采取的策略便是将逻辑地址对0x100000取模，这就是8086的地址回绕</p>
<h3 id="A20GATE"><a href="#A20GATE" class="headerlink" title="A20GATE"></a>A20GATE</h3><p>到了80286这个拥有24位地址总线的CPU，但是<code>intel</code>为了兼容考虑，在实模式下，仍然只开启A0-A19这低20位地址线，并采用8086地址回绕。</p>
<p>所以我们需要突破A20地址线，这就是说的打开<strong>A20GATE</strong></p>
<p>其实打开A20很简单，只要把0x92端口的第1位（最低位是第0位）置1，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">in al, 0x92<br>or al, 0000_0010b<br>out 0x92, al<br></code></pre></td></tr></table></figure>

<h2 id="CR0寄存器的PE位"><a href="#CR0寄存器的PE位" class="headerlink" title="CR0寄存器的PE位"></a>CR0寄存器的PE位</h2><p>先了解一下CR0-CR3寄存器</p>
<h3 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h3><p>控制寄存器用于控制和确定处理器的操作模式以及当前执行任务的特性，在80386中有4个，分别为CR0、CR1、CR2、CR3，其中CR1被保留，为后续开发做准备。</p>
<p>CR0包括指示处理器工作方式的控制位，包含启用和禁止分页管理机制的控制位，包含控制浮点协处理器操作的控制位。CR2及CR3由分页管理机制使用。CR0中的位5—位30及CR3中的位0至位11是保留位，这些位不能是随意值，必须为0。</p>
<p>详细介绍一下CR0寄存器</p>
<h3 id="CR0"><a href="#CR0" class="headerlink" title="CR0"></a>CR0</h3><p>下两图出自《操作系统真象还原》</p>
<p><img src="/img/OS/13.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><img src="/img/OS/14.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>第0位：PE，即<code>Protection Enable</code>，为0时是实模式，为1时是保护模式，所以PE便是我们的目标，将他置1也很简单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov eax,cr0<br>or eax,0x00000001<br>mov cr0,eax<br></code></pre></td></tr></table></figure>

<p>顺带提一嘴，只有CR0的最高位PG为1，开启分页时，CR3才会被启用</p>
<h2 id="about-CPU"><a href="#about-CPU" class="headerlink" title="about CPU"></a>about CPU</h2><h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><p>虽然执行单元EU是CPU执行指令的唯一部件，但是CPU 的指令执行过程分为取指令、译码、执行三个步骤。每个步骤都是独立执行的， CPU 可以一边执行指令，一边取指令，一边译码。CPU是只能一次处理一个指令，但是也妹说不能干的别的事啊😋。这样就使效率得到极大的提升。</p>
<h4 id="jmp清空"><a href="#jmp清空" class="headerlink" title="jmp清空"></a>jmp清空</h4><p>CPU 是按照程序中指令顺序来填充流水线的，大多是情况下当前指令和下一条指令在空间上是挨着的。但如果当前执行的指令是jmp ，下一条指令已经被送上流水线译码了，第三条指令已经被送上流水线取指。but因为<code>cs:ip</code>已经跳到不知道哪去了，所以 CPU 在遇到无条件转移指令 jmp 时，会清空流水线。</p>
<h3 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h3><p>随着流水线而来的一个问题便是，如果CPU遇到一个条件跳转语句，假设两条路分别时A、B，那么CPU在还未执行判断语句的时候，是如何选择A或B进入流水线的？</p>
<p>最简单的方法是 2 位预测法。用 2 位 bit 的计数器来记录跳转状态，每跳转一次加 1，如果未跳转就减 1。当遇到跳转指令时，如果计数器的值大于 1 则跳转，如果小于等于 1 则不跳。这基于的原理是当一件事情发生时，有很大概率下一次还会发生。</p>
<p>同时，intel架构的CPU中存在分支目标缓冲器（<code>Branch Target Buffer</code>,BTB），会将分支指令的地址和跳转信息存放在其中，CPU在下一次遇到分支指令时，会在BTB寻找相同地址的指令，参照其中的统计信息，选择将哪一个分支载入流水线。如果未找到相同地址，会使用<code>Static Predictor</code>，即静态预测，这是基于大量代码的共同特征总结的。比如循环结构体一般都在结束跳转指令的上方。</p>
<p>当然加载错误的分支指令也没关系，只要在CPU执行前制止就行了，虽然清空流水线装载正确分支的花销挺大的😓</p>
<h3 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h3><p>就是 CPU 中运行的指令并不按照代码中的顺序执行，而是按照一定的策略打乱顺序执行，也许后面的指令先执行，当然，得保证指令之间不具备相关性 。</p>
<p>比如下面的例子，第一个指令需要去内存中寻找值，而add ebx只需要简单的加法操作就行了，所以CPU就会在指令1访问内存的等待中执行指令2.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov rax, [0xfff00]<br>add ebx, 1<br></code></pre></td></tr></table></figure>

<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p> 缓存是 20 世纪最大的发明，其原理是用一些存取速度较快的存储设备作为数据缓冲区，避免频繁访问速度较慢的低速存储设备，归根结底的原因是低速存储设备是整个系统的瓶颈，缓存用来缓解“瓶颈设备”的压力（摘自《操作系统真象还原》）。都知道木桶原理，和硬盘相比，内存<code>DRAM</code>的速度已经够快了，却还是连<code>CPU</code>的尾气都吃不到。所以，内存8行，就出现了三级缓存L1、L2、L3（<code>SRAM</code>，静态随机访问储存器，期待能在amd的三缓里在装系统的那天😚）。寄存器和<code>SRAM</code>在速度上是同一级别的东西，都是用相同的存储电路实现的，用的都是触发器，速度快的飞起 。</p>
<p> 比如当循环执行一段code时，短时间内这块内存将被高频率访问，如果将这块code放到三缓里，就能极大的提高程序运行效率。</p>
<h2 id="PE模式下的内存保护措施"><a href="#PE模式下的内存保护措施" class="headerlink" title="PE模式下的内存保护措施"></a>PE模式下的内存保护措施</h2><p><del>都叫保护模式了保护措施能少🐎</del></p>
<p><strong>段描述符&amp;选择子</strong></p>
<p>对使用<code>selector</code>的检查：<code>check</code>索引值，<code>check</code>是否使用了gdt中索引【0】的段描述表</p>
<p>针对段描述符中的<code>type</code>字段，有下列几个原则</p>
<ul>
<li>只有具备可执行属性的段才能加载到CS寄存器中</li>
<li>只具有可执行属性的段不允许加载到除CS外的段寄存器中</li>
<li>只有具备可写属性的段才能加载到SS寄存器中</li>
<li>至少具备可读属性的段才能加载到DS、ES、FS、GS段寄存器中</li>
</ul>
<p><code>check type</code>后，还会<code>chekc</code> P位确认内存段是否存在，访问过相应段后，会将其段描述符中的A位置1（这算什么，标记？bushi）</p>
<p><strong>Data &amp; System Segment</strong></p>
<p>段界限check</p>
<p>段界限：<br>$$<br>（段界限+1）*粒度-1<br>$$<br>这要注意这个就差不多了</p>
<p>ok，前置知识基本讲完了，可以进入保护模式了！！ヾ(≧▽≦*)o</p>
<h2 id="Let’s-go"><a href="#Let’s-go" class="headerlink" title="Let’s go!"></a>Let’s go!</h2><h3 id="boot-inc"><a href="#boot-inc" class="headerlink" title="boot.inc"></a>boot.inc</h3><p>多了好多配置信息</p>
<p><code>nasm</code>还挺人性化的，可以在数字中加”_”使数位更清楚，且不影响值的表示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;-----loader &amp; kernel msg-----<br>LOADER_BASE_ADDR equ 0x900<br>LOADER_START_SECTOR equ 0x2<br>;-----the value of GDT-----<br>DESC_G_4K	 		equ 1000_0000_00000000_00000000b     ;G: 4kb<br>DESC_D_32	 		equ  100_0000_00000000_00000000b     ;D: 32位<br>DESC_L 				equ   00_0000_00000000_00000000b	 ;L: 32位代码段<br>DESC_AVL			equ    0_0000_00000000_00000000b	 ;无意义<br>DESC_LIMIT_CODE2 	equ      1111_00000000_00000000b	 ;平坦模式，就是0xf<br>DESC_LIMIT_DATA2 	equ DESC_LIMIT_CODE2<br>DESC_LIMIT_VIDEO2	equ      0000_00000000_00000000b	 ;这边设置video是为了表示显存（0xb8000），所以limit设置0<br>DESC_P				equ           10000000_00000000b	 ;P: 存在<br>DESC_DPL_0			equ            0000000_00000000b     <br>DESC_DPL_1			equ	       	   0100000_00000000b<br>DESC_DPL_2			equ            1000000_00000000b<br>DESC_DPL_3			equ            1100000_00000000b<br>DESC_S_CODE			equ              10000_00000000b	 ;S: 非系统段，代码段<br>DESC_S_DATA			equ DESC_S_CODE                      ;S: 非系统段，数据段<br>DESC_S_sys 			equ		 		 00000_00000000b     ;S: 系统段<br>DESC_TYPE_CODE		equ 		      1000_00000000b     ;只执行代码段<br>DESC_TYPE_DATA		equ 		      0010_00000000b     ;只读，向下扩展的数据段<br>;-----code gdt高位4字节-----<br>DESC_CODE_HIGH4		equ (0x00 &lt;&lt; 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00<br>;-----data gdt高四位字节-----<br>DESC_DATA_HIGH4		equ (0x00 &lt;&lt; 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00<br>;-----video gdt高四位字节-----<br>DESC_VIDEO_HIGH4	equ (0x00 &lt;&lt; 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0b<br>;-----the value of selector-----<br>RPL0	equ 00b<br>RPL1	equ 01b<br>RPL2	equ 10b<br>RPL3	equ 11b<br>TI_GDT	equ 000b<br>TI_LDT	equ 100b<br></code></pre></td></tr></table></figure>

<h3 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h3><p>mbr和前面的还是一样的。只是load.s经过编译后得到的load.bin的size大于512，所以读取扇区的数量改变，这边直接改成4了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov eax,LOADER_START_SECTOR<br>mov bx,LOADER_BASE_ADDR<br>mov cx,4                    ;sector count<br>call rd_disk_m_16<br></code></pre></td></tr></table></figure>

<p>pack的时候脚本也有变化</p>
<p><code>count</code>改为4</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">dd <span class="hljs-attribute">if</span>=./loader.bin \<br>        <span class="hljs-attribute">of</span>=./img.img \<br>        <span class="hljs-attribute">bs</span>=512 <span class="hljs-attribute">count</span>=4 <span class="hljs-attribute">seek</span>=2 <span class="hljs-attribute">conv</span>=notrunc<br></code></pre></td></tr></table></figure>

<h3 id="Load-S"><a href="#Load-S" class="headerlink" title="Load.S"></a>Load.S</h3><p>load.s要改的就比较多了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs assembly">%include &quot;boot.inc&quot;<br>SECTION LOADER vstart=LOADER_BASE_ADDR<br>LOADER_STACK_TOP equ LOADER_BASE_ADDR<br><br>jmp loader_start<br><br>GDT_BASE:                   ;gdt[0]为空<br>	dd 0x00000000<br>	dd 0x00000000<br>	<br>CODE_DESC:                  ;gdt[1]<br>	dd 0x0000ffff<br>	dd DESC_CODE_HIGH4<br>	<br>DATA_STACK_DESC:            ;gdt[2] <br>	dd 0x0000ffff<br>	dd DESC_DATA_HIGH4<br>	<br>VIDEO_DESC:                 ;gdt[3]<br>	dd 0x80000007           ;(0xbffff-0xb8000)/4k = 7 <br>	dd DESC_VIDEO_HIGH4<br><br>GDT_SIZE	equ $ - GDT_BASE    ; 0x8*4<br>GDT_LIMIT	equ GDT_SIZE - 1    ; 0x20 - 1 <br>times 60 dq 0<br><br>SELECTOR_CODE 	equ (0x0001&lt;&lt;3) + TI_GDT + RPL0<br>SELECTOR_DATA	equ (0x0002&lt;&lt;3) + TI_GDT + RPL0<br>SELECTOR_VIDEO 	equ (0x0003&lt;&lt;3) + TI_GDT + RPL0<br><br>gdt_ptr	dw GDT_LIMIT<br>	dd GDT_BASE<br><br>loadermsg db &#x27;korey is ready&#x27;<br><br>loader_start:<br>	mov sp, LOADER_BASE_ADDR ;print &quot;korey is ready&quot;<br>	mov bp, loadermsg<br>	mov cx, 14<br>	mov ax, 0x1301<br>	mov bx, 0x001f<br>	mov dx, 0x1800<br>	int 0x10<br>	<br>	in al, 0x92              ;open A20 gate<br>	or al, 0000_0010b<br>	out 0x92, al<br>	<br>	lgdt [gdt_ptr]           ;load gdt<br>	 <br>	mov eax, cr0             ;real mode to protection mode<br>	or eax, 0x00000001<br>	mov cr0, eax<br>	<br>	jmp dword SELECTOR_CODE:p_mode_start    ;刷新流水线<br>	<br>[bits 32]<br>p_mode_start:<br>	mov ax,SELECTOR_DATA<br>	mov ds,ax<br>	mov es,ax<br>	mov ss,ax<br>	mov esp,LOADER_STACK_TOP<br>	mov ax,SELECTOR_VIDEO<br>	mov gs,ax<br>	<br>	mov byte [gs:160], &#x27;P&#x27;<br>	<br>	jmp $<br></code></pre></td></tr></table></figure>

<p>可以看到<code>jmp dword SELECTOR_CODE:p_mode_start</code>这句代码感觉有点脱裤子放屁，毕竟程序流只要顺序执行也能滑到<code>p_mode_start </code>，那为什么用<code>jmp</code>呢？因为CPU采用流水线作业（上面提到过），会将几条指令放在一起重叠执行（感觉<code>mips</code>架构这个特点就很显著），所以<code>p_mode_start</code>是32位的，和16位的一起执行直接能把CPU的CPU干烧了，这是其一。其二是虽然进入了32位保护模式，ds，cs，ss这些段寄存器里还是16位的段基址。其他位默认0，导致D位&#x3D;0，也即是进入32位模式了段寄存器还是被认为是16位，那就麻烦大了。并且<code>mov cs, xxx</code>这类指令是被禁止的，只有用远调用指令<code>call</code>，远转移指令<code>jmp</code>，远返回指令<code>retf</code>可以间接改变CS的值。所以用<code>jmp</code>清空流水线并刷新CS寄存器。</p>
<p>展示个结果</p>
<p><img src="/img/OS/15.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h1 id="0x3-PE-to-Kernel-！！"><a href="#0x3-PE-to-Kernel-！！" class="headerlink" title="0x3:PE to Kernel ！！"></a>0x3:PE to Kernel ！！</h1><h2 id="获取内存容量"><a href="#获取内存容量" class="headerlink" title="获取内存容量"></a>获取内存容量</h2><p><code>BIOS</code>的0x15中断号中，提供了3个子功能来获取内存容量</p>
<ul>
<li>EAX &#x3D; 0xE820，遍历所有内存</li>
<li>EAX &#x3D; 0xE801，检测低15MB和16MB-4GB的内存，最大支持4GB</li>
<li>AH &#x3D; 0x88，最多检测64MB，超过64MB也返回64MB</li>
</ul>
<p>这三种功能返回的信息详细程度一词5递减，但是操作复杂程度反之</p>
<h3 id="0xE820"><a href="#0xE820" class="headerlink" title="0xE820"></a>0xE820</h3><p>此功能每次会返回一个不同属性的内存布局信息，因此需要不停迭代来获取全部内容</p>
<p>因为返回的信息较为丰富，寄存器无法存放，所以需要结构体来存放返回值，此结构体为地址范围描述符（Address Range Descripter Structure, ARDS），格式如下图。此表来自《操作系统真象还原》</p>
<p><img src="/img/OS/17.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>type字段的意义如下。此表来自《操作系统真象还原》</p>
<p><img src="/img/OS/18.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>同时，0xE820在中断前，还需要几个寄存器布置参数，返回后的值也储存在几个寄存器中。此表来自《操作系统真象还原》</p>
<p><img src="/img/OS/19.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>动手写一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs assembly">；前半部分和load.S一样<br>times 60 dq 0<br><br>total_mem_bytes dd 0<br>gdt_ptr 	dw GDT_LIMIT<br>		dd GDT_BASE<br>		<br>ards_buf times	244 db 0<br>ards_nr		dw 0<br><br>loader_start:<br>	xor ebx,ebx<br>	mov esi, ards_buf<br>	mov es,esi<br>	xor esi,esi<br>	xor edi,edi<br>	.e820:<br>		mov eax,0xe820<br>		mov ecx,20<br>		mov edx,0x534d4150<br>		int 0x15<br>		add edi,20<br>		cmp ebx, 0<br>		jnz .e820<br>		<br>	jmp $<br></code></pre></td></tr></table></figure>

<p>看看ARDS</p>
<p><img src="/img/OS/20.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="0xE801"><a href="#0xE801" class="headerlink" title="0xE801"></a>0xE801</h3><p>只需eax寄存器&#x3D;0xe801即可执行int 0x15调用</p>
<p>返回时，eax &#x3D; ecx，粒度为1kB，只显示15MB及以下的内存容量；ebx &#x3D; edx，粒度为64KB，显示16MB-4GB的内存</p>
<p>but我们获得的内存总量总是比实际大小小1MB，这是为了兼容老ISA设备，最后输出的时候加上去就行了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs assembly">loader_start:<br>	.e801:<br>		mov ax, 0xe801<br>		int 0x15<br>		mov ecx, 0x00000400<br>    		mul ecx<br>    		add eax, 0x100000<br>    		mov esi, eax<br>    		xor eax, eax<br>    		mov eax, ebx<br>    		mov ecx, 0x10000<br>    		mul ecx<br>    		add esi, eax<br>		<br>		mov [total_mem_bytes],esi<br>		<br>		jmp $<br></code></pre></td></tr></table></figure>

<p><img src="/img/OS/16.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">#megs: 256<br>#megs: 128<br>megs: 64<br>#megs: 64<br>#megs: 16<br>#megs: 8<br></code></pre></td></tr></table></figure>

<p>和配置文件相符</p>
<h3 id="0x88"><a href="#0x88" class="headerlink" title="0x88"></a>0x88</h3><p>只需ah &#x3D; 0x88，返回值也只有一个，存储在eax中，最后再加上一个1MB就行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs assembly">loader_start:<br>	.88:<br>		mov ah, 0x88<br>		int 0x15<br>		mov ecx,0x400<br>		mul ecx<br>		add eax,0x100000<br>		<br>		mov [total_mem_bytes],eax<br>		<br>		jmp $<br></code></pre></td></tr></table></figure>

<h2 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h2><p>内存分页解除了线性内存与物理内存一一对应的关系，通过映射关系，将线性地址映射到任意物理地址</p>
<p>内存分页由CPU提供硬件（页部件）支持，通过建立页表，以及页表查询来实现映射关系，这也是由CPU完成的，毕竟在CPU看来，一切都是慢速设备，不如自己来。当然还得感谢CPU设计师与OS设计师的合作。</p>
<p>至于什么是映射关系，这个应该不用笔者赘述了</p>
<h3 id="一级页表"><a href="#一级页表" class="headerlink" title="一级页表"></a>一级页表</h3><p>32位架构的CPU的地址总线的max是4GB</p>
<p>CPU以4kB为粒度，将内存分为一页页，此为一级页表</p>
<p>此时我们需要一个地方来存储每页内存的信息，这个地方就是页表（Page Table）。页表中的项称为页表项（ Page Table Entry，PTE ），其大小是 4 字节，页表项的作用是存储内存物理地址。当访问一个线性地址时，实际上就是在访问页表项中所记录的物理内存地址。</p>
<p>下图为一级页表示意图。来自《操作系统真象还原》</p>
<p><img src="/img/OS/21.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>页表项0-11位为页内寻址</p>
<p>页表项12-31位为该页表项在页表中的<code>index</code></p>
<p>页表的地址被存放在CR3寄存器中，可以通过CR3寄存器中页表项的物理地址（此时还未开启分页）+ index*4找到目标页表项对应的物理地址，最后加上低12位的偏移，就能访问对应的物理地址</p>
<p>But，想一下，4GB总内存，以4kB的粒度分，光页表项就有<code>0x100000</code>之多，存储这些页表项就要花费4MB大小的内存。并且每个进程都有独立的页表，光是这些内存就是一笔很大的开销，那怎么办捏？</p>
<p>一级页表不行，👴再套一层不行🐎</p>
<p>所以二级页表他来了</p>
<h3 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h3><p>先看一下二级页表示意图。下图来自《操作系统真象还原》</p>
<p><img src="/img/OS/22.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>这次CPU学聪明了，先创建一个4KB大小的页目录表，其中存放着1024个页目录项（Page Directory Entry， PDE）。何为页目录项？就是页表的物理地址，页目录项大小同页表项一样，都用来描述一个物理页的物理地址，其大小都是 4 字节。</p>
<p>页目录表中共 1024 个页表，也就是有 1024 个页目录项 。一个页目录项中记录一个页表物理页地址，物理页地址是指页的物理地址，在页目录项及页表项中记录的都是页的物理地址。</p>
<p>中间层果然是万能的(bushi)</p>
<p>二级页表虽然原理与一级页表相同，但是寻址方式发生了一点小变化</p>
<p>对于一个32位虚拟地址：</p>
<ul>
<li>0-11位：页内偏移</li>
<li>12-21位：PTE索引</li>
<li>22-31位：PDE索引</li>
</ul>
<p>计算公式和一级页表类似</p>
<p>反正这些公式的计算是<code>CPU</code>帮👴干的</p>
<p>突然，受尽压榨的<code>CPU</code>发现，这些页表项和页目录项都是以4KB为粒度，也就是说最后12位都是0，反正固定不变的东西，存放点信息不是美滋滋，于是，<code>PTE</code>和<code>PDE</code>就被改造调教开发成了下面的模样🥵。下图来自《操作系统真象还原》</p>
<p><img src="/img/OS/23.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<ul>
<li>P：present 1：存在内存中&#x2F;0：不存在内存中</li>
<li>RW：read&#x2F;wirte 1：可读可写&#x2F;0：可读不可写</li>
<li>US：user&#x2F;super 1：非特权&#x2F;0：特权</li>
<li>PWT：Page-level Write-Through，页级通写位，置1表示此内存页是高速缓存，此处置0即可</li>
<li>PCD：Page-level Cache Disable，页级高速缓存禁止位，置1表示此内存页启用高速缓存，此处置0即可</li>
<li>A：Accessed，访问位 1：被CPU访问过，用来统计访问频率</li>
<li>D：Dirty，脏页，CPU对一个内存页执行写操作后，会对此内存页对应的页表项D位置1</li>
<li>PAT：Page Attribute Table，太复杂了，👴不写了</li>
<li>G：Global，全局位，与下文的TLB有关</li>
<li>AVL：Available，可用位，但是可不可用跟CPU👴有什么关系</li>
</ul>
<h3 id="开启页表"><a href="#开启页表" class="headerlink" title="开启页表"></a>开启页表</h3><p>boot.inc添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;-----页表物理地址-----<br>PAGE_DIR_TABLE_POS 	equ 0x100000<br>;-----页表属性-----<br>PG_P	equ 1b<br>PG_RW_R	equ 00b<br>PG_RW_W	equ 10b<br>PG_US_S equ 000b<br>PG_US_U	equ 100b<br></code></pre></td></tr></table></figure>

<p>load.S</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;-----前面就是进入PE模式-----<br>call setup_page<br>	<br>sgdt [gdt_ptr]                                          ;保存当前gdt的值<br>mov ebx, [gdt_ptr + 2]                                  ;使gdt_base和selector3的base加0xc0000000<br>or dword [ebx + 0x18 + 4], 0xc0000000<br>add dword [gdt_ptr + 2], 0xc0000000<br>add esp, 0xc0000000<br>	<br>mov eax, PAGE_DIR_TABLE_POS                             ;将页目录表物理地址存进CR3<br>mov cr3, eax<br>	<br>mov eax, cr0                                            ;开启分页<br>or eax, 0x80000000<br>mov cr0, eax<br>	<br>lgdt [gdt_ptr]<br>mov byte [gs:160], &#x27;V&#x27;<br>	<br>jmp $<br><br><br>setup_page:<br>	[bits 32]<br>	mov ecx,0x1000<br>	mov esi,0<br>	.clear_page_dir:                                    ;将页目录表清零<br>		mov byte[PAGE_DIR_TABLE_POS + esi],0<br>		inc esi<br>		loop .clear_page_dir<br>	<br>	.create_pde:<br>		mov eax, PAGE_DIR_TABLE_POS                     ;第一个页表创建在物理地址0x101000<br>		add eax, 0x1000<br>		mov ebx, eax<br>		<br>		or eax, PG_US_U | PG_RW_W | PG_P                ;用户权限、可写、存在<br>		mov [PAGE_DIR_TABLE_POS + 0x0], eax             ;将index=0 &amp; 768的页目录项赋值为0x101007，c00以上的用于内核空间<br>		mov [PAGE_DIR_TABLE_POS+0xc00], eax<br>		sub eax, 0x1000<br>		mov [PAGE_DIR_TABLE_POS+4092],eax               ;将页目录表的物理地址作为最后一个页目录项<br>		<br>		mov ecx, 256                                    ;将0x100000以下的内存，作为第一个页表中的PTE<br>		mov esi, 0<br>		mov edx, PG_US_U | PG_RW_W | PG_P<br>		<br>		.create_pte:<br>			mov [ebx+esi*4], edx<br>			add edx, 0x1000<br>			inc esi<br>			loop .create_pte<br>			<br>	mov eax, PAGE_DIR_TABLE_POS                         ;将1MB-1GB的内存全部映射到高处，使得内核和操作系统共享同一片物理地址<br>	add eax, 0x2000<br>	or eax, PG_US_U | PG_RW_W | PG_P<br>	mov ebx, PAGE_DIR_TABLE_POS<br>	mov ecx, 254<br>	mov esi, 769<br>		<br>	.create_kernel_pde:<br>		mov [ebx+esi*4], eax<br>		inc esi<br>		add eax, 0x1000<br>		loop .create_kernel_pde<br>			<br>	ret<br></code></pre></td></tr></table></figure>

<h3 id="虚拟地址访问页表"><a href="#虚拟地址访问页表" class="headerlink" title="虚拟地址访问页表"></a>虚拟地址访问页表</h3><p>用<code>info tab</code>可以查看页表映射</p>
<p><img src="/img/OS/24.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>这边解释一下为什么会有这种奇怪的映射，因为页目录表的最后一项页目录项是页表的物理地址，对应虚拟地址的高10位为0x3ff</p>
<p>此时页目录项为<code>0x100000</code>，最后一个页表项还是原来的页目录项，就是这玩意被用了两次，第一次当页目录项，第二次当页表项，无限套娃。其余两个也是这个思路，所以访问<code>0xfffffXXX</code>的虚拟地址，就能访问页表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0xfffff000-0xffffffff -&gt; 0x000000100000-0x000000100fff<br></code></pre></td></tr></table></figure>

<h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><p>在二级页表中，从虚拟地址转换到物理地址需要访问三次内存，那三级、四级页表怎么办？对于<code>CPU</code>来说，访问内存无疑是一种降低效率的行为，所以<code>TLB</code>（Translation Lookaside Buffer，快表）就出现了。</p>
<p><code>TLB</code> 中的条目是虚拟地址的高 20 位到物理地址高 20 位的映射结果。<code>TLB</code>将近期访问的虚拟地址转换成物理地址后，一一对应储存起来，当<code>CPU</code>下一次需要转换时，会先来<code>TLB</code>中查询，查到就直接拿去用，如果没查到对应的物理地址，会在转换后更新<code>TLB</code>。</p>
<p>可以使用<code>invlpg</code>指令更新<code>TLB</code></p>
<h2 id="load-kernel！"><a href="#load-kernel！" class="headerlink" title="load kernel！"></a>load kernel！</h2><p>对于linux kernel，并不采用纯汇编的方式来编写（虽然这8是8行😅），将C和汇编结合起来会更便于理解</p>
<p>因为我们是在linux操作系统中，kernel的文件格式是elf，所以在loader kernel文件前，我们还需要对elf文件有足够了解</p>
<h3 id="elf-文件"><a href="#elf-文件" class="headerlink" title="elf 文件"></a>elf 文件</h3><p>ELF，Executable and Linkable Format，可执行链接格式。</p>
<p>ELF文件提供了两种文件视图，链接格式视图和执行格式视图。链接视图是以节（section）为单位，执行视图是以段（segment）为单位。接视图就是在链接时用到的视图，而执行视图则是在执行时用到的视图。</p>
<p><img src="/img/OS/25.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>先来看看elf header</p>
<h4 id="ELF-header"><a href="#ELF-header" class="headerlink" title="ELF header"></a>ELF header</h4><p>ELF header位于文件的开始位置，它的主要目的是定位文件的其他部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs assembly">typedef struct elf32_hdr<br>&#123;<br>	  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */<br>	  Elf32_Half	e_type;			/* Object file type */<br>	  Elf32_Half	e_machine;		/* Architecture */<br>	  Elf32_Word	e_version;		/* Object file version */<br>	  Elf32_Addr	e_entry;		/* Entry point virtual address */<br>	  Elf32_Off	e_phoff;		/* Program header table file offset */<br>	  Elf32_Off	e_shoff;		/* Section header table file offset */<br>	  Elf32_Word	e_flags;		               /* Processor-specific flags */<br>	  Elf32_Half	e_ehsize;		/* ELF header size in bytes */<br>	  Elf32_Half	e_phentsize;		/* Program header table entry size */<br>	  Elf32_Half	e_phnum;		/* Program header table entry count */<br>	  Elf32_Half	e_shentsize;		/* Section header table entry size */<br>	  Elf32_Half	e_shnum;		/* Section header table entry count */<br>	  Elf32_Half	e_shstrndx;		/* Section header string table index */<br>&#125; Elf32_Ehdr;<br></code></pre></td></tr></table></figure>

<p><strong>e_ident：</strong>16字节，含义如下图</p>
<p><img src="/img/OS/27.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>e_type：</strong>2字节，文件类型，类型有以下几个</p>
<p><img src="/img/OS/28.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>e_machine：</strong>2字节，文件架构，有以下几个架构</p>
<p><img src="/img/OS/29.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>用<code>readelf -h</code>即可查看elf header详细信息</p>
<p><img src="/img/OS/26.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h4 id="Program-header-table"><a href="#Program-header-table" class="headerlink" title="Program header table"></a>Program header table</h4><p>位于elf header之后，程序头表(Program header table)列举了有效的段(segments)和他们的属性（执行视图）</p>
<p>程序头是一个结构的数组，每一个结构都表示一个段(segments)。在可执行文件或者共享链接库中所有的节(sections)都被分为不同的几个段(segments)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">typedef struct elf32_phdr&#123;<br>	  Elf32_Word	p_type;   <br>	  Elf32_Off	    p_offset;<br>	  Elf32_Addr	p_vaddr;<br>	  Elf32_Addr	p_paddr;<br>	  Elf32_Word	p_filesz;<br>	  Elf32_Word	p_memsz;<br>	  Elf32_Word	p_flags;<br>	  Elf32_Word	p_align;<br>&#125; Elf32_Phdr;<br></code></pre></td></tr></table></figure>

<p>程序头的索引地址(e_phoff)、段数量(e_phnum)、表项大小(e_phentsize)都是通过 ELF头部信息获取的。</p>
<p><strong>p_type：</strong>指明该段的类型</p>
<p><img src="/img/OS/30.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>p_flags：</strong>指明该段的标志</p>
<p><img src="/img/OS/31.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>下图画红线的0x20字节便是一个程序头表</p>
<p><img src="/img/OS/32.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>当然，也可以使用<code>readelf -l</code>得到详细信息</p>
<p><img src="/img/OS/33.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>以上，便是elf文件浅析</p>
<h3 id="now-lets’s-go"><a href="#now-lets’s-go" class="headerlink" title="now lets’s go!"></a>now lets’s go!</h3><p>先随便写个kernel，内联汇编用起来还是爽的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs assembly">#include &lt;stdio.h&gt;<br><br>int main(void)<br>&#123;<br>	while(1)<br>	&#123;<br>		asm(<br>		    &quot;mov byte ptr [gs:170], &#x27;W&#x27;;&quot;<br>		    &quot;mov byte ptr [gs:172], &#x27;E&#x27;;&quot;<br>		    &quot;mov byte ptr [gs:174], &#x27;L&#x27;;&quot;<br>		    &quot;mov byte ptr [gs:176], &#x27;C&#x27;;&quot;<br>		    &quot;mov byte ptr [gs:178], &#x27;O&#x27;;&quot;<br>		    &quot;mov byte ptr [gs:180], &#x27;M&#x27;;&quot;<br>		    &quot;mov byte ptr [gs:182], &#x27;E&#x27;;&quot;<br>		    &quot;mov byte ptr [gs:184], &#x27; &#x27;;&quot;<br>		    &quot;mov byte ptr [gs:186], &#x27;k&#x27;;&quot;<br>		    &quot;mov byte ptr [gs:188], &#x27;o&#x27;;&quot;<br>		    &quot;mov byte ptr [gs:190], &#x27;r&#x27;;&quot;<br>		    &quot;mov byte ptr [gs:192], &#x27;e&#x27;;&quot;<br>		    &quot;mov byte ptr [gs:194], &#x27;y&#x27;;&quot;<br>		    &quot;mov byte ptr [gs:196], &#x27;&#x27;&#x27;;&quot;<br>		    &quot;mov byte ptr [gs:198], &#x27;O&#x27;;&quot;<br>		    &quot;mov byte ptr [gs:200], &#x27;S&#x27;;&quot;<br>		);<br>	&#125;<br>	return 0;		    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们需要将kernel载入到内存中，完成解析，书中是将kernel载入到0x70000处，解析程序入口到0x1500处，笔者也就照着来了。</p>
<p>用脚本完成编译链接，0x1500对应的虚拟地址为0xc0001500</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>gcc -m32 -c ./kernel/kernel.c -o ./kernel/kernel.o -masm=intel<br>ld -melf_i386 ./kernel/kernel.o -Ttext 0xc0001500 -e main -o ./kernel/kernel.bin<br></code></pre></td></tr></table></figure>

<p>完成载入和解析后，便可以跳到kernel处，load的任务就结束了（我的任务完成啦🤪）</p>
<p>以下便是代码的变化</p>
<p><strong>boot.inc</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;-----add-----<br>KERNEL_START_SECTOR	equ 0x9<br>KERNEL_BIN_BASE_ADDR	equ 0x70000<br>KERNEL_ENTRY_POINT	equ 0xc0001500<br>PT_NULL	equ 0<br></code></pre></td></tr></table></figure>

<p><strong>pack.sh</strong></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">dd <span class="hljs-attribute">if</span>=./kernel/kernel.bin \<br>        <span class="hljs-attribute">of</span>=./img.img \<br>        <span class="hljs-attribute">bs</span>=512 <span class="hljs-attribute">count</span>=200 <span class="hljs-attribute">seek</span>=9 <span class="hljs-attribute">conv</span>=notrunc<br></code></pre></td></tr></table></figure>

<p><strong>load.s</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;开启保护模式......<br>p_mode_start:<br>		mov ax,SELECTOR_DATA<br>		mov ds,ax<br>		mov es,ax<br>		mov ss,ax<br>		mov esp,LOADER_STACK_TOP<br>		mov ax,SELECTOR_VIDEO<br>		mov gs,ax<br>		<br>		mov eax, KERNEL_START_SECTOR<br>		mov ebx, KERNEL_BIN_BASE_ADDR<br>		mov ecx, 200<br>		call rd_disk_m_32                       ;和rd_dsik_m_16一样，寄存器换成32位就行<br>		<br>		call setup_page                         <br>	<br>		sgdt [gdt_ptr]<br>		mov ebx, [gdt_ptr + 2]<br>		or dword [ebx + 0x18 + 4], 0xc0000000<br>		add dword [gdt_ptr + 2], 0xc0000000<br>		add esp, 0xc0000000<br>	<br>		mov eax, PAGE_DIR_TABLE_POS<br>		mov cr3, eax<br>	<br>		mov eax, cr0<br>		or eax, 0x80000000<br>		mov cr0, eax<br>	<br>		lgdt [gdt_ptr]                          ;开启分页<br>		<br>		jmp SELECTOR_CODE:enter_kernel          ;刷新流水线，虽然不刷也莫得关系<br>		<br>		enter_kernel:<br>			call kernel_init<br>			mov esp, 0xc009f000<br>			jmp KERNEL_ENTRY_POINT<br><br><br>;......<br>kernel_init:<br>	[bits 32]<br>	xor eax, eax<br>	xor ebx, ebx<br>	xor ecx, ecx<br>	xor edx, edx<br>	<br>	mov dx, [KERNEL_BIN_BASE_ADDR + 42]         ;length of program header<br>	mov ebx, [KERNEL_BIN_BASE_ADDR + 28]        <br>	add ebx, KERNEL_BIN_BASE_ADDR               ;program header table start address<br>	mov cx, [KERNEL_BIN_BASE_ADDR+44]           ;count of program header<br>	<br>	.each_segment:<br>		cmp byte[ebx + 0],PT_NULL               ;if [ebx+0] == 0,the program header is empty<br>		je .PTNULL<br>		<br>		push dword [ebx + 16]                   ;segment size<br>		mov eax, [ebx+4]<br>		add eax, KERNEL_BIN_BASE_ADDR<br>		push eax                                ;src<br>		push dword [ebx + 8]                    ;dst<br>		<br>		call mem_cpy<br>		add esp, 12                             ;recover<br>		<br>	.PTNULL:<br>		add ebx, edx                            ;next program header<br>		loop .each_segment<br>		ret<br>	<br>	mem_cpy:                                     ;模仿memcpy函数，待我去看看memcpy源码<br>		cld<br>		push ebp<br>		mov ebp, esp<br>		push ecx<br>		<br>		mov edi, [ebp+8]<br>		mov esi, [ebp+12]<br>		mov ecx, [ebp+16]<br>		rep movsb                                ;将ds:esi处size为ecx的data，复制到es:edi处，逐字节拷贝<br>		<br>		pop ecx<br>		leave                                    ;恢复栈帧<br>		ret<br></code></pre></td></tr></table></figure>

<p>最后的效果的就是这样</p>
<p><img src="/img/OS/34.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h1 id="0x4-实现自己的输出函数"><a href="#0x4-实现自己的输出函数" class="headerlink" title="0x4:实现自己的输出函数"></a>0x4:实现自己的输出函数</h1><p>在此之前，我们在屏幕上输出，要么是依靠BIOS中断，要么是直接对显存进行操作</p>
<p>但我们是什么，是尊贵的kernel！输出这件事，应该只要轻轻的call一个function，就能完成</p>
<p>所以，是时候写一个输出函数了（虽然只是对显存操作测封装罢了🤔）</p>
<h2 id="单个字符输出"><a href="#单个字符输出" class="headerlink" title="单个字符输出"></a>单个字符输出</h2><p>print.S</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs assembly">TI_GDT	equ 0<br>RPL0 	equ 0<br>SELECTOR_VIDEO	equ (0x0003&lt;&lt;3) + TI_GDT + RPL0<br><br>[bits 32]<br>section .text<br><br>global put_char<br><br>put_char:<br>	[bits 32]<br>	pushad                                     ;保存寄存器的值<br>	mov ax, SELECTOR_VIDEO<br>	mov gs, ax<br>	<br>	mov dx, 0x3d4                              ;获取光标的值<br>	mov al, 0x0e<br>	out dx, al<br>	mov dx, 0x03d5<br>	in al, dx<br>	mov ah, al<br>	<br>	mov dx, 0x3d4<br>	mov al, 0x0f<br>	out dx, al<br>	mov dx, 0x03d5<br>	in al, dx<br>	<br>	mov bx, ax<br>	mov ecx, [esp+36]                           ;将要输出字符的ascii码值给ecx<br>	<br>	cmp cl, 0x0d<br>	jz .is_carriage_return<br>	cmp cl, 0xa<br>	jz .is_line_feed           <br>	<br>	cmp cl, 0x8<br>	jz .is_backspace<br>	jmp .put_other<br><br>;-----退格-----<br>.is_backspace:<br>	[bits 32]<br>	dec bx<br>	shl bx, 1<br>	<br>	mov byte [gs:bx], 0x20<br>	inc bx<br>	mov byte [gs:bx], 0x7<br>	shr bx, 1<br>	jmp .set_cursor<br>	<br>	<br>.put_other:<br>        [bits 32]<br>	shl bx, 1<br>	mov [gs:bx], cl<br>	inc bx<br>	mov byte [gs:bx], 0x7<br>	shr bx, 1<br>	inc bx<br>	cmp bx, 2000<br>	jl .set_cursor<br><br>;-----换行-----<br>.is_line_feed:<br>	[bits 32]<br>	add bx, 80<br>	cmp bx, 2000<br>	jl .set_cursor<br>;-----回车-----	<br>.is_carriage_return:<br>	[bits 32]<br>	xor dx, dx<br>	mov ax, bx<br>	mov si, 80	<br>	div si<br>	sub bx, dx<br>	<br>	jmp .set_cursor<br><br>;-----滚屏-----<br>.roll_screen:                                   ;简单来说，就是把1-24的data移动到0-23行，因为我们无需考虑缓存问题<br>	[bits 32]                                 <br>	cld <br>	mov eax, 960                                ;960*4 = 3840<br><br>	mov esi, 0xc00b80a0                         ;第1行<br>	mov edi, 0xc00b8000                         ;第0行<br>	rep movsd                                   ;4字节4字节移动<br>	<br>	mov ebx, 3840                               ;第24行第一个光标的值<br>	mov ecx, 80<br>	<br>	.cls:                                       ;使最后一行为空白行<br>		[bits 32]<br>		mov word [gs:ebx], 0x720<br>		add ebx, 2<br>		loop .cls<br>		mov bx, 1920<br>;-----存储当前光标的值-----		<br>.set_cursor:<br>	[bits 32]<br>	mov dx, 0x3d4<br>	mov al,0x0e<br>	out dx, al<br>	mov dx, 0x03d5<br>	mov al, bh<br>	out dx, al<br>	<br>	mov dx, 0x3d4<br>	mov al, 0xf<br>	out dx,al<br>	mov dx, 0x03d5<br>	mov al, bl<br>	out dx, al<br>;-----恢复寄存器状态-----<br>	.put_char_done:<br>		[bits 32]<br>		popad<br>		ret<br>	<br></code></pre></td></tr></table></figure>

<p>在显存的文本显示模式中，两个字节显示一个字符——一字节为字符的值，一字节为字符的属性。所以获取光标的值*2才是对应字符在显存中的偏移。</p>
<p>bochs的屏幕，可以容纳80*25共2000个字符，占据4000字节，所以换行就是简单粗暴的光标值+80，回车是当前光标值 - （当前光标值对80取模）。至于滚行的原理，就是简单粗暴的把1-24行移动到0-23行，突出一个不考虑缓存🤪</p>
<h2 id="字符串输出"><a href="#字符串输出" class="headerlink" title="字符串输出"></a>字符串输出</h2><p>好吧其实就是对单个字符输出的封装呜呜</p>
<p>print.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _LIB_KERNEL_PRINT_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _LIB_KERNEL_PRINT_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdint.h&quot;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">put_char</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> char_csci)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">put_str</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<p>print.S</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs assembly">global put_str<br><br>put_str:<br>	push ebx<br>	push ecx<br>	xor ecx, ecx<br>	mov ebx, [esp + 12]<br>	.go_on:<br>		mov cl, [ebx]<br>		cmp cl, 0<br>		jz .str_over<br>		push ecx<br>		call put_char<br>		add esp, 4<br>		inc ebx<br>		jmp .go_on<br><br>.str_over:<br>	pop ecx<br>	pop ebx<br>	ret<br></code></pre></td></tr></table></figure>

<p>main.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;print.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	put_str(<span class="hljs-string">&quot;begin\r\n&quot;</span>);<br>	put_str(<span class="hljs-string">&quot;aaaaaaaaaa&quot;</span>);<br>	put_str(<span class="hljs-string">&quot;\b\b\b\b\b\b\b\b&quot;</span>);<br>	put_str(<span class="hljs-string">&quot;bbbbbbbbbb\r\n&quot;</span>);<br>	put_str(<span class="hljs-string">&quot;end\r\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ld.sh</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>nasm -f elf -o ./lib/kernel/print.o ./lib/kernel/print.S<br>gcc -m32 -I lib/kernel/ -c -o ./kernel/main.o ./kernel/main.c -masm=intel<br>ld -melf_i386 ./kernel/main.o ./lib/kernel/print.o -Ttext 0xc0001500 -e main -o ./kernel/kernel.bin <br></code></pre></td></tr></table></figure>

<p>运行发现结果还是可以的</p>
<p><img src="/img/OS/35.png" srcset="/img/loading.gif" lazyload></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Record-of-Learn/" class="category-chain-item">Record-of-Learn</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/OS/" class="print-no-link">#OS</a>
      
        <a href="/tags/linux/" class="print-no-link">#linux</a>
      
        <a href="/tags/kernel/" class="print-no-link">#kernel</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>关于作死试图搓一个32位操作系统不得不说的事</div>
      <div>http://example.com/2023/11/20/OS/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>korey0sh1</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年11月20日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/12/30/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/" title="2023【祭】无为的一年">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">2023【祭】无为的一年</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/11/02/11/" title="11月比赛合集">
                        <span class="hidden-mobile">11月比赛合集</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      京ICP证123456号
    </a>
  </span>
  
    
      <span>
        <a
          href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
          rel="nofollow noopener"
          class="beian-police"
          target="_blank"
        >
          
            <span style="visibility: hidden; width: 0">|</span>
            <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
          
          <span>京公网安备12345678号</span>
        </a>
      </span>
    
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
